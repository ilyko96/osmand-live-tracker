<!DOCTYPE html>
<!-- TODO: CURSOR_TOLERANCE is now map coordinates related; should only consider pixels -->
<!-- TODO: add a page, where one can add smth line waypoint (lon/lat and description), which is later displayed on track -->
<!-- TODO: automatically separate tracks (probably on server side) by delay in timestamps and draw them separately -->
<html lang="en">
	<head>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.2.1/css/ol.css" type="text/css">
		<style>
			body {
				width: 100%;
				/*height: 100%;*/
				overflow: hidden; /* Hide scrollbars */
				margin: unset;
			}
			.map {
				height: 1px;
				min-height: 100vh;
				/*min-width: 94vw;*/
				width: 100%;
				/*padding: 5px;*/
			}

			table {
				border: 1px solid black;
			}
			th, td {
				padding: 1px;
			}
			th {
				text-align: left;
			}

			/* === Custom control buttons === */
			/* Home button */
			.ol-control-custom {
				top: 65px;
				left: .5em;
			}
			.ol-touch .ol-control-custom {
				top: 80px;
			}
			/* Marker button */
			.ol-control-marker {
				top: 95px;
				left: .5em;
			}
			.ol-touch .ol-control-marker {
				top: 118px;
			}
			/* Cursor info panel */
			.ol-control-panel {
				width: 180px;
				height: auto;
				left: unset;
				top: unset;
				right: 8px;
				bottom: 24px;
				background-color: rgba(177, 119, 255, 0.8);
				display: none;
			}
			.ol-control-panel:hover {
				background-color: rgba(177, 119, 255, 0.8);
			}
			/* Track info table */
			.ol-control-table {
				width: auto;
				height: auto;
				left: unset;
				bottom: unset;
				right: 40px;
				top: 8px;
				background-color: rgba(167, 255, 217, 0.8);
				display: block;
			}
			.ol-control-table:hover {
				background-color: rgba(167, 255, 217, 0.8);
			}
			/* Refresh panel */
			.ol-control-refresh {
				width: auto;
				height: auto;
				right: unset;
				bottom: unset;
				left: 40px;
				top: 8px;
				background-color: rgba(167, 255, 217, 0.8);
				/*display: block;*/
			}
			.ol-control-refresh:hover {
				background-color: rgba(167, 255, 217, 0.8);
			}


			/* === 2 column layout === */
			.column {
				float: left;
				width: 33.3%;
			}
			/* Clear floats after the columns */
			.row:after {
				content: "";
				display: table;
				clear: both;
			}

			/* === Cursor popup === */
			.ol-popup {
				position: absolute;
				background-color: white;
				box-shadow: 0 1px 4px rgba(0,0,0,0.2);
				/*padding-left: 15px;*/
				/*padding-bottom: 15px;*/
				padding: 10px;
				border-radius: 10px;
				border: 1px solid #cccccc;
				bottom: 12px;
				left: -50px;
				min-width: 180px;
			}
			.ol-popup:after, .ol-popup:before {
				top: 100%;
				border: solid transparent;
				content: " ";
				height: 0;
				width: 0;
				position: absolute;
				pointer-events: none;
			}
			.ol-popup:after {
				border-top-color: white;
				border-width: 10px;
				left: 48px;
				margin-left: -10px;
			}
			.ol-popup:before {
				border-top-color: #cccccc;
				border-width: 11px;
				left: 48px;
				margin-left: -11px;
			}
			.ol-popup-closer {
				text-decoration: none;
				position: absolute;
				top: 2px;
				right: 8px;
			}
			.ol-popup-closer:after {
				content: "✖";
			}
		</style>
		<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.2.1/build/ol.js"></script>
		<script src="util.js"></script>
		<title>v2.0</title>
	</head>
<body>
<!--	<h3>Track my bike v2.0</h3>-->
<!--	<div class="row">-->
<!--		<div class="column">-->
<!--		</div>-->
<!--		<div class="column">-->
<!--		</div>-->
<!--	</div>-->
	<div id="map" class="map"></div>
	<div id="popup" class="ol-popup">
		<a href="#" id="popup-closer" class="ol-popup-closer"></a>
		<div id="popup-content"></div>
	</div>
	<div class="ol-control-panel ol-unselectable ol-control" id="cur_info_container">
		<div>Sender: <span id="cur_sender"></span></div>
		<div>Time: <span id="cur_timestamp"></span></div>
		<div>Speed: <span id="cur_speed"></span></div>
		<div>Altitude: <span id="cur_ele"></span></div>
		<div>Distance: <span id="cur_dst"></span></div>
	</div>
	<div class="ol-control-table ol-unselectable ol-control" id="info_table">
		<table>
            <tr><th>Track name: </th><th id="track_name"></th></tr>
			<tr><th>Track started at: </th><th id="time_on_start"></th></tr>
			<tr><th>Time at marker: </th><th id="time_at_marker"></th></tr>
			<tr><th>Speed at marker: </th><th id="speed_at_marker"></th></tr>
			<tr><th>Total distance: </th><th id="dst_travelled"></th></tr>
			<tr style="color: gray;"><th>Last refresh: </th><th id="last_refresh"></th></tr>
		</table>
	</div>
	<div class="ol-control-refresh ol-unselectable ol-control" id="refresh_panel">
<!--		<label for="refresh_interval">Refresh interval:</label>-->
		<select id="refresh_interval" style="width: auto;">
			<option value="-1">Never</option>
			<option value="5000">5 sec</option>
			<option value="30000">30 sec</option>
			<option value="60000">1 min</option>
			<option value="120000" selected>2 min</option>
			<option value="300000">5 min</option>
		</select>
		<button id="update_btn">U</button>
	</div>
	<script type="text/javascript">
		const URL_GETPOINTS = 'http://batukah.000webhostapp.com/osholm/v2.0/getPoints.php';
		const CURSOR_TOLERANCE = 4000;
		const DEBUG = false;
		const HDOP_TITLES = ['Excellent accuracy', 'Average accuracy', 'Poor accuracy'];
		const HDOP_COLORS = ['green', 'rgb(180,162,33)', 'red'];

		var waypoints = []; // Originally downloaded JSON
		var coords = []; // lon/lat array for showing track on map
        var currentTrack = null; // track_uid of currently shown track
		var projectFunction = ol.proj.getTransform('EPSG:4326', 'EPSG:3857');

		var sourceTrack = new ol.source.Vector({}); // source for track
		var sourceMarker = new ol.source.Vector({}); // source for marker
		var trackLine = new ol.geom.LineString([]); // ol.geom.LineString instance for track
		var markerPoint = new ol.geom.Point([]); // ol.geom.Point instance for marker

		sourceTrack.addFeature(new ol.Feature(trackLine));
		sourceMarker.addFeature(new ol.Feature(markerPoint));

		function centerMapOnTrack() {
			map.getView().fit(trackLine, {padding: [100, 100, 100, 100]});
		}
		function centerMapOnMarker() {
			let view = map.getView();
			view.setCenter(trackLine.getLastCoordinate());
			view.setZoom(15);
		}
		var DEBUG_curDataIndex = 0;
		const DEBUG_DATABATCH = 10;
		var updateWaypoints = function(centerTrack=false) {
			// console.log('updateWaypoints');
			let url = URL_GETPOINTS;
			if (waypoints.length > 0) url += '?starting=' + waypoints[waypoints.length-1]['uid'];
			// <DEBUG>
			if (DEBUG) {
				url = URL_GETPOINTS + '?starting=' + DEBUG_curDataIndex + '&ending=' + (DEBUG_curDataIndex + DEBUG_DATABATCH);
				DEBUG_curDataIndex += DEBUG_DATABATCH;
			}
			// </DEBUG>
			getJSON(url,  function(err, data) {
				if (err != null || data == null) {
					alert('Could not update data!');
                    console.error('Requested url: ' + url);
					console.error(err);
					return;
				}
				if ('error' in data) {
                    alert('Could not update data! Error occurred!');
                    console.error('Requested url: ' + url);
                    console.error(data['error']);
                    return;
                }
				if (!('tracks' in data) || !('points' in data)) {
                    alert('Loaded data is invalid!');
                    console.error('Requested url: ' + url);
                    console.error(data);
                    return;
                }

				// If there is no errors, then parse data
                let tracks = data.tracks; // Every request returns the whole table of tracks
				// This is temporary solution while separate tracks functionality is not implemented
				let last_track_uid = Math.max.apply(Math, tracks.map(function(o) { return o.uid; }));
				if (currentTrack == null) currentTrack = tracks.find(x => x.uid == last_track_uid);
				if (currentTrack.uid !== last_track_uid) alert('A newer track exists in database. Please reload the whole page!');
				let points = data.points.filter(x => x.track_uid == currentTrack.uid);
				if (points.length > 0) { // new data exists
					// Preprocess received data
					let waypoints_upd = points.sort(function(a, b) { return a.uid - b.uid}); // Sort ascending
					let coords_upd = waypoints2coords(waypoints_upd); // prepare lon/lat array
					let coordsTransformed_upd = projectFunction(coords_upd);

					// Concatenate with already existing data
					waypoints = waypoints.concat(waypoints_upd);
					coords = coords.concat(coords_upd);

					// Update track
					trackLine.setCoordinates(coords);
					trackLine.applyTransform(projectFunction);

					// Update marker
					markerPoint.setCoordinates(ol.proj.fromLonLat(coords[coords.length-1]));

					// Center map on track
					if (!waypoints || centerTrack) centerMapOnTrack();

					// ======= Update info on page =======
					let lwp = waypoints[waypoints.length - 1]; // last waypoint

					// Update track_started_at info
                    track_name_obj.innerText = currentTrack.name;
					if (lwp.timestamp_log) time_on_start_obj.innerText = waypoints[0].timestamp_log;
					else if (lwp.timestamp_server) time_on_start_obj.innerText = waypoints[0].timestamp_server + ' (request time)';
					else time_on_start_obj.innerText = "unknown";
					// Update last_update
					if (lwp.timestamp_log) time_at_marker_obj.innerText = lwp.timestamp_log;
					else if (lwp.timestamp_server) time_at_marker_obj.innerText = lwp.timestamp_server + ' (request time)';
					else time_at_marker_obj.innerText = "unknown";
					// Update current_speed
					if (lwp.speed)  speed_at_marker_obj.innerText = Number(parseFloat(lwp.speed) * 3.6).toFixed(1) + " km/h";
					else speed_at_marker_obj.innerText = "unknown";
					// Update travelled distance
					dst_travelled_obj.innerText = formatLineStringLnegth(trackLine);
				}

				// Update last_update info
				last_refresh_obj.innerText = getFormattedDate();
			});
		}; updateWaypoints(true); // initial update with full track

		// onClick for [update] button
		document.getElementById('update_btn').addEventListener('click', function(e) {
			updateWaypoints();
			setUpdateInterval();
		});

		// Popup on cursor
		var popupContent = document.getElementById('popup-content');
		var popupCloser = document.getElementById('popup-closer');

		var cursorOverlay = new ol.Overlay({
			element: document.getElementById('popup'),
			autoPan: true,
			autoPanAnimation: {
				duration: 10
			}
		});
		function closePopup() {
			cursorOverlay.setPosition(undefined);
			popupCloser.blur();
			arbitraryPopup = false;
		}
		popupCloser.onclick = function() {
			closePopup();
			return false;
		};

		var layerTrack = new ol.layer.Vector({
			name: 'Track',
			source: sourceTrack,
			style: styleTrack
		});
		var map = new ol.Map({
			target: 'map',
			layers: [
				new ol.layer.Tile({
					name: 'Tile',
					source: new ol.source.OSM()
				}),
				layerTrack,
				new ol.layer.Vector({
					name: 'Marker',
					source: sourceMarker,
					style: styleMarker
				})
			],
			view: new ol.View({
				center: ol.proj.fromLonLat([37.41, 8.82]),
				zoom: 4
			}),
			controls: ol.control.defaults().extend([
				new ol.control.ScaleLine({bar: true, text: false}),
				new ol.control.FullScreen(),
				new CustomControl({
					label: '⯐',
					className: 'ol-control-marker ol-control-custom',
					callback: centerMapOnMarker
				}),
				new CustomControl({
					label: '⌂',
					className: 'ol-control-home ol-control-custom',
					callback: centerMapOnTrack
				}),
				new ol.control.Control({ element: document.getElementById('cur_info_container') }),
				new ol.control.Control({ element: document.getElementById('info_table') }),
				new ol.control.Control({ element: document.getElementById('refresh_panel') })
			]),
			overlays: [cursorOverlay]
		});

		var refresh_interval_obj = document.getElementById('refresh_interval');
		var track_name_obj = document.getElementById('track_name');
        var time_at_marker_obj = document.getElementById('time_at_marker');
		var time_on_start_obj = document.getElementById('time_on_start');
		var speed_at_marker_obj = document.getElementById('speed_at_marker');
		var dst_travelled_obj = document.getElementById('dst_travelled');
		var last_refresh_obj = document.getElementById('last_refresh');

		var cur_info_container_obj = document.getElementById('cur_info_container');
		var cur_sender_obj = document.getElementById('cur_sender');
		var cur_timestamp_obj = document.getElementById('cur_timestamp');
		var cur_speed_obj = document.getElementById('cur_speed');
		var cur_ele_obj = document.getElementById('cur_ele');
		var cur_dst_obj = document.getElementById('cur_dst');

		// Autorefresh part
		var refresh_interval = parseInt(refresh_interval_obj.options[refresh_interval_obj.selectedIndex].value);
		var refresh_interval_id = null;
		refresh_interval_obj.onchange = function() {
			// console.log('onchange');
			refresh_interval = parseInt(refresh_interval_obj.options[refresh_interval_obj.selectedIndex].value);
			setUpdateInterval();
		};
		var setUpdateInterval = function() {
			// console.log('setUpdateInterval: ' + refresh_interval);
			if (refresh_interval_id)  clearInterval(refresh_interval_id);
			if (refresh_interval > 0) {
				refresh_interval_id = window.setInterval(updateWaypoints, refresh_interval);
			}
		}; setUpdateInterval();

		// Cursor part
		var cursor = null;
		var arbitraryPopup = false; // true, if popup shows non-track point atm. needed to trigger closePopup() correctly
		// Pointer onMouseMove
		var displayCursor = function(coord, click=false, alt=false) {
			let closestPoint = trackLine.getClosestPoint(coord);
			if (Math.sqrt(Math.pow(closestPoint[0] - coord[0], 2) + Math.pow(closestPoint[1] - coord[1], 2)) > CURSOR_TOLERANCE) {
				// Cursor not in tolerance
				cursor = null;
				map.render();
				// Hide info panel
				cur_info_container_obj.style.display = "none";
				// If not in tolerance and no alt (i.e. track point request) ~ ordinary click on map -> close popup
				if (click && !alt) {
					closePopup();
				}
			} else {
				// Cursor in tolerance
				if (cursor === null)  cursor = new ol.geom.Point(closestPoint);
				else cursor.setCoordinates(closestPoint);
				map.render();

				// Trying to find closest segment of trackLine
				let closestSegment = findClosestSegment(trackLine.getCoordinates(), closestPoint);
				let ind = closestSegment[0];
				let t = closestSegment[1];

				let wp = null;
				if (ind && t)  wp = waypoints[ind];

				let infoContent = '';
				let hdopCat = null; // hdop category: 0, 1 or 2
				if (wp) {
					// Calculated distance so far
					let cursorTrack = new ol.geom.LineString(coords.slice(0, ind + 1));
					cursorTrack.applyTransform(projectFunction);
					// Considering that wp can be in the middle of last segment
					let crds = cursorTrack.getCoordinates();
					let l = crds[crds.length-1], lp = crds[crds.length-2];
					let dxy = [l[0]-lp[0], l[1]-lp[1]];
					crds[crds.length-1] = [lp[0] + t*dxy[0], lp[1] + t*dxy[1]];
					cursorTrack.setCoordinates(crds);
					// Calculating distance itself
					let dst = ol.sphere.getLength(cursorTrack);

					// Updating info on page if found
					let timestamp = (wp.timestamp_log ? wp.timestamp_log : wp.timestamp_server);
					let speed = null;
					let ele = null;
					let sender = null;
					let hdop = null;
					if (wp.speed) speed = Number(parseFloat(wp.speed) * 3.6).toFixed(1) + " km/h";
					if (wp.altitude) ele = Number(parseFloat(wp.altitude)).toFixed(1) + " m";
					if (wp.sender) sender = wp.sender;
					if (wp.hdop) hdop = wp.hdop;

					if (hdop) hdopCat = categorizeHDOP(hdop);

					// Info panel in the bottom-right corner
					cur_info_container_obj.style.display = "block";
					cur_sender_obj.innerText = sender ? sender : 'unknown';
					cur_timestamp_obj.innerText = timestamp;
					cur_speed_obj.innerText = speed ? speed : 'unknown';
					cur_ele_obj.innerText = ele ? ele : 'unknown';
					cur_dst_obj.innerText = formatDistance(dst);

					// Info for popup
					infoContent = '';
					if (sender) infoContent += 'Sender: ' + sender;
					infoContent += (infoContent.length > 0 ? '<br>Time: ' : '') + timestamp;
					if (speed) infoContent += '<br>Speed: ' + speed;
					if (ele) infoContent += '<br>Altitude: ' + ele;
					infoContent += (infoContent.length > 0 ? '<br>Travelled: ' : '') + formatDistance(dst);
				}

				if (click && !alt) {
					// Click without alt but in tolerance lead to track-popup
					let hdms = ol.coordinate.toStringHDMS(ol.proj.toLonLat(closestPoint)).replace(/\s/g, '').replace(/N/g, 'N ');
					if (hdopCat != null) popupContent.innerHTML = '<code title="'+HDOP_TITLES[hdopCat]+'" style="color: '+HDOP_COLORS[hdopCat]+';">' + hdms + '</code>';
					else  popupContent.innerHTML = '<code>' + hdms + '</code>';
					popupContent.innerHTML += '<p>' + infoContent + '</p>';
					arbitraryPopup = false;
					cursorOverlay.setPosition(closestPoint);
				}
			}
			if (click && alt) {
				// Independently of tolerance, if alt used with click, showing coordinate of exact click position
				let hdms = ol.coordinate.toStringHDMS(ol.proj.toLonLat(coord)).replace(/\s/g, '').replace(/N/g, 'N ');
				popupContent.innerHTML = '<code>' + hdms + '</code>';
				arbitraryPopup = true;
				cursorOverlay.setPosition(coord);
			}
		};
		map.on('pointermove', function(evt) {
			if (evt.dragging) return;
			var coord = map.getEventCoordinate(evt.originalEvent);
			displayCursor(coord);
		});
		map.on('click', function(evt) {
			displayCursor(evt.coordinate);
		});
		map.on('singleclick', function(evt) {
			displayCursor(evt.coordinate, true, evt.originalEvent.altKey);
		});

		layerTrack.on('postrender', function(evt) {
			var vectorContext = ol.render.getVectorContext(evt);
			vectorContext.setStyle(styleCursor);
			if (cursor !== null)
				vectorContext.drawGeometry(cursor);
		});
	</script>
</body>
</html>