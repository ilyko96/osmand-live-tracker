<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.2.1/css/ol.css" type="text/css">
		<style>
			.map {
				height: 600px;
				width: 100%;
			}

			.ol-control-custom {
				top: 65px;
				left: .5em;
			}
			.ol-touch .ol-control-custom {
				top: 80px;
			}

			/*.ol-control-home {*/
			/*}*/
			.ol-control-marker {
				top: 95px;
				left: .5em;
			}

			.column {
				float: left;
				width: 50%;
			}

			/* Clear floats after the columns */
			.row:after {
				content: "";
				display: table;
				clear: both;
			}
		</style>
		<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.2.1/build/ol.js"></script>
		<script src="util.js"></script>
		<title>v2.0</title>
	</head>
<body>
	<div class="row">
		<div class="column">
<!--			<h2>Track my bike</h2>-->
			<div>Time at marker position: <span id="time_at_marker">unknown</span></div>
			<div>Speed at marker position: <span id="speed_at_marker">unknown</span></div>
			<div style="color: gray;">Last refresh: <span id="last_refresh">unknown</span></div>
		</div>
		<div class="column">
			<div>
				<label for="refresh_interval">Choose refreshing interval:</label>
				<select id="refresh_interval">
					<option value="-1">No refresh</option>
					<option value="5000">5s</option>
					<option value="30000">30s</option>
					<option value="60000">1m</option>
					<option value="120000" selected>2m</option>
					<option value="300000">5m</option>
				</select>
				<button id="update_btn">Manual update</button>
			</div>
			<div id="test"></div>
		</div>
	</div>
	<div id="map" class="map"></div>
	<script type="text/javascript">
		const URL_GETPOINTS = 'http://batukah.000webhostapp.com/osholm/v2.0/getPoints.php';
		const CURSOR_TOLERANCE = 5000;

		var waypoints = []; // Originally downloaded JSON
		var coords = []; // lon/lat array for showing track on map
		var projectFunction = ol.proj.getTransform('EPSG:4326', 'EPSG:3857');

		var sourceTrack = new ol.source.Vector({}); // source for track
		var sourceMarker = new ol.source.Vector({}); // source for marker
		var trackLine = new ol.geom.LineString([]); // ol.geom.LineString instance for track
		var markerPoint = new ol.geom.Point([]); // ol.geom.Point instance for marker

		sourceTrack.addFeature(new ol.Feature(trackLine));
		sourceMarker.addFeature(new ol.Feature(markerPoint));

		function centerMapOnTrack() {
			map.getView().fit(trackLine, {padding: [100, 100, 100, 100]});
		}
		function centerMapOnMarker() {
			let view = map.getView();
			view.setCenter(trackLine.getLastCoordinate());
			view.setZoom(15);
		}
		var updateWaypoints = function(centerTrack=false) {
			// console.log('updateWaypoints');
			let url = URL_GETPOINTS;
			if (waypoints.length > 0)  url += '?starting=' + waypoints[waypoints.length-1]['uid'];
			// <DEBUG>
			// url = URL_GETPOINTS + '?starting=20&ending=30';
			// </DEBUG>
			getJSON(url,  function(err, data) {
				if (err != null || data == null) {
					alert('Could not update data!');
					console.error(err);
					return;
				}
				if (data.length > 0) { // new data exists
					// Preprocess received data
					let waypoints_upd = data.sort(function(a, b) { return a.uid - b.uid}); // Sort ascending
					let coords_upd = waypoints2coords(waypoints_upd); // prepare lon/lat array
					let coordsTransformed_upd = projectFunction(coords_upd);

					// Concatenate with already existing data
					waypoints = waypoints.concat(waypoints_upd);
					coords = coords.concat(coords_upd);

					// Update track
					trackLine.setCoordinates(coords);
					trackLine.applyTransform(projectFunction);

					// Update marker
					markerPoint.setCoordinates(ol.proj.fromLonLat(coords[coords.length-1]));

					// Center map on track
					if (!waypoints || centerTrack) centerMapOnTrack();

					// Update info on page
					let lwp = waypoints[waypoints.length - 1]; // last waypoint
					// Update last_update
					if (lwp.timestamp_log)  time_at_marker_obj.innerText = lwp.timestamp_log;
					else if (lwp.timestamp_server)  time_at_marker_obj.innerText = lwp.timestamp_server + ' (request time)';
					else time_at_marker_obj.innerText = "unknown";
					// Update current_speed
					if (lwp.speed)  speed_at_marker_obj.innerText = Number(parseFloat(lwp.speed) * 3.6).toFixed(1) + " km/h";
					else speed_at_marker_obj.innerText = "unknown";
				}

				// Update last_update info
				last_refresh_obj.innerText = getFormattedDate();
			});
		}; updateWaypoints(true); // initial update with full track

		// onClick for [update] button
		document.getElementById('update_btn').addEventListener('click', function(e) {
			updateWaypoints();
			setUpdateInterval();
		});

		var layerTrack = new ol.layer.Vector({
			name: 'Track',
			source: sourceTrack,
			style: styleTrack
		});
		var map = new ol.Map({
			target: 'map',
			layers: [
				new ol.layer.Tile({
					name: 'Tile',
					source: new ol.source.OSM()
				}),
				layerTrack,
				new ol.layer.Vector({
					name: 'Marker',
					source: sourceMarker,
					style: styleMarker
				})
			],
			view: new ol.View({
				center: ol.proj.fromLonLat([37.41, 8.82]),
				zoom: 4
			}),
			controls: ol.control.defaults().extend([
					new CustomControl({
						label: '⯐',
						className: 'ol-control-marker ol-control-custom',
						callback: centerMapOnMarker
					}),
					new CustomControl({
						label: '⌂',
						className: 'ol-control-home ol-control-custom',
						callback: centerMapOnTrack
					})
			])
		});
		map.addControl(new ol.control.ScaleLine({bar: true, text: false}));
		map.addControl(new ol.control.FullScreen());

		// Autorefresh part
		var refresh_interval_obj = document.getElementById('refresh_interval');
		var time_at_marker_obj = document.getElementById('time_at_marker');
		var speed_at_marker_obj = document.getElementById('speed_at_marker');
		var last_refresh_obj = document.getElementById('last_refresh');

		var debug_test_obj = document.getElementById('test');

		var refresh_interval = parseInt(refresh_interval_obj.options[refresh_interval_obj.selectedIndex].value);
		var refresh_interval_id = null;
		refresh_interval_obj.onchange = function() {
			// console.log('onchange');
			refresh_interval = parseInt(refresh_interval_obj.options[refresh_interval_obj.selectedIndex].value);
			setUpdateInterval();
		};
		var setUpdateInterval = function() {
			// console.log('setUpdateInterval: ' + refresh_interval);
			if (refresh_interval_id)  clearInterval(refresh_interval_id);
			if (refresh_interval > 0) {
				refresh_interval_id = window.setInterval(updateWaypoints, refresh_interval);
			}
		}; setUpdateInterval();

		// Cursor part
		var cursor = null;
		// Pointer onMouseMove
		var displayCursor = function(coord) {
			var closestPoint = trackLine.getClosestPoint(coord);
			if (Math.sqrt(Math.pow(closestPoint[0] - coord[0], 2) + Math.pow(closestPoint[1] - coord[1], 2)) > CURSOR_TOLERANCE) {
				cursor = null;
				map.render();
				debug_test_obj.innerHTML = '';
				return;
			}
			if (cursor === null)  cursor = new ol.geom.Point(closestPoint);
			else cursor.setCoordinates(closestPoint);
			map.render();

			// Trying to find closest segment of trackLine
			let closestSegment = findClosestSegment(trackLine.getCoordinates(), closestPoint);
			let ind = closestSegment[0];
			let t = closestSegment[1];

			if (ind && t) { // Updating info on page if found
				let wp = waypoints[ind];
				let content = (wp.timestamp_log ? wp.timestamp_log : wp.timestamp_server);
				if (wp.speed) content += '  ' + Number(parseFloat(wp.speed) * 3.6).toFixed(1) + " km/h";

				debug_test_obj.innerHTML = content;
			} else {
				debug_test_obj.innerHTML = '';
			}
		};
		map.on('pointermove', function(evt) {
			if (evt.dragging) return;
			var coord = map.getEventCoordinate(evt.originalEvent);
			displayCursor(coord);
		});
		map.on('click', function(evt) {
			displayCursor(evt.coordinate);
		});

		layerTrack.on('postrender', function(evt) {
			var vectorContext = ol.render.getVectorContext(evt);
			vectorContext.setStyle(styleCursor);
			if (cursor !== null)
				vectorContext.drawGeometry(cursor);
		});
	</script>
</body>
</html>