<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.2.1/css/ol.css" type="text/css">
		<style>
			.map {
				height: 550px;
				width: 100%;
				padding: 5px;
			}

			table {
				border: 1px solid black;
			}
			th, td {
				padding: 1px;
			}
			th {
				text-align: left;
			}

			/* === Custom control buttons === */
			.ol-control-custom {
				top: 65px;
				left: .5em;
			}
			.ol-touch .ol-control-custom {
				top: 80px;
			}
			.ol-control-marker {
				top: 95px;
				left: .5em;
			}
			.ol-touch .ol-control-marker {
				top: 118px;
			}
			.ol-control-panel {
				width: 180px;
				height: 75px;
				left: unset;
				top: unset;
				right: 8px;
				bottom: 24px;
				background-color: rgba(177, 119, 255, 0.8);
				display: none;
			}
			.ol-control-panel:hover {
				background-color: rgba(177, 119, 255, 0.8);
			}

			/* === 2 column layout === */
			.column {
				float: left;
				width: 33.3%;
			}
			/* Clear floats after the columns */
			.row:after {
				content: "";
				display: table;
				clear: both;
			}

			/* === Cursor popup === */
			.ol-popup {
				position: absolute;
				background-color: white;
				box-shadow: 0 1px 4px rgba(0,0,0,0.2);
				/*padding-left: 15px;*/
				/*padding-bottom: 15px;*/
				padding: 10px;
				border-radius: 10px;
				border: 1px solid #cccccc;
				bottom: 12px;
				left: -50px;
				min-width: 180px;
			}
			.ol-popup:after, .ol-popup:before {
				top: 100%;
				border: solid transparent;
				content: " ";
				height: 0;
				width: 0;
				position: absolute;
				pointer-events: none;
			}
			.ol-popup:after {
				border-top-color: white;
				border-width: 10px;
				left: 48px;
				margin-left: -10px;
			}
			.ol-popup:before {
				border-top-color: #cccccc;
				border-width: 11px;
				left: 48px;
				margin-left: -11px;
			}
			.ol-popup-closer {
				text-decoration: none;
				position: absolute;
				top: 2px;
				right: 8px;
			}
			.ol-popup-closer:after {
				content: "✖";
			}
		</style>
		<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.2.1/build/ol.js"></script>
		<script src="util.js"></script>
		<title>v2.0</title>
	</head>
<body>
	<h3>Track my bike v2.0</h3>
	<div class="row">
		<div class="column">
			<table>
				<tr><th>Track started at: </th><th id="time_on_start"></th></tr>
				<tr><th>Time at marker: </th><th id="time_at_marker"></th></tr>
				<tr><th>Speed at marker: </th><th id="speed_at_marker"></th></tr>
				<tr><th>Total distance: </th><th id="dst_travelled"></th></tr>
				<tr style="color: gray;"><th>Last refresh: </th><th id="last_refresh"></th></tr>
			</table>
		</div>
		<div class="column">
			<div>
				<label for="refresh_interval">Refresh interval:</label>
				<select id="refresh_interval" style="width: auto;">
					<option value="-1">Never</option>
					<option value="5000">5s</option>
					<option value="30000">30s</option>
					<option value="60000">1m</option>
					<option value="120000" selected>2m</option>
					<option value="300000">5m</option>
				</select><br>
				<button id="update_btn">Manual update</button>
			</div>
		</div>
	</div>
	<div id="map" class="map"></div>
	<div id="popup" class="ol-popup">
		<a href="#" id="popup-closer" class="ol-popup-closer"></a>
		<div id="popup-content"></div>
	</div>
	<div class="ol-control-panel ol-unselectable ol-control" id="cur_info_container">
		<div>Sender: <span id="cur_sender"></span></div>
		<div>Time: <span id="cur_timestamp"></span></div>
		<div>Speed: <span id="cur_speed"></span></div>
		<div>Altitude: <span id="cur_ele"></span></div>
	</div>
	<script type="text/javascript">
		const URL_GETPOINTS = 'http://batukah.000webhostapp.com/osholm/v2.0/getPoints.php';
		const CURSOR_TOLERANCE = 5000;
		const DEBUG = false;

		var waypoints = []; // Originally downloaded JSON
		var coords = []; // lon/lat array for showing track on map
		var projectFunction = ol.proj.getTransform('EPSG:4326', 'EPSG:3857');

		var sourceTrack = new ol.source.Vector({}); // source for track
		var sourceMarker = new ol.source.Vector({}); // source for marker
		var trackLine = new ol.geom.LineString([]); // ol.geom.LineString instance for track
		var markerPoint = new ol.geom.Point([]); // ol.geom.Point instance for marker

		sourceTrack.addFeature(new ol.Feature(trackLine));
		sourceMarker.addFeature(new ol.Feature(markerPoint));

		function centerMapOnTrack() {
			map.getView().fit(trackLine, {padding: [100, 100, 100, 100]});
		}
		function centerMapOnMarker() {
			let view = map.getView();
			view.setCenter(trackLine.getLastCoordinate());
			view.setZoom(15);
		}
		var DEBUG_curDataIndex = 0;
		const DEBUG_DATABATCH = 10;
		var updateWaypoints = function(centerTrack=false) {
			// console.log('updateWaypoints');
			let url = URL_GETPOINTS;
			if (waypoints.length > 0) url += '?starting=' + waypoints[waypoints.length-1]['uid'];
			// <DEBUG>
			if (DEBUG) {
				url = URL_GETPOINTS + '?starting=' + DEBUG_curDataIndex + '&ending=' + (DEBUG_curDataIndex + DEBUG_DATABATCH);
				DEBUG_curDataIndex += DEBUG_DATABATCH;
			}
			// </DEBUG>
			getJSON(url,  function(err, data) {
				if (err != null || data == null) {
					alert('Could not update data!');
					console.error(err);
					return;
				}
				if (data.length > 0) { // new data exists
					// Preprocess received data
					let waypoints_upd = data.sort(function(a, b) { return a.uid - b.uid}); // Sort ascending
					let coords_upd = waypoints2coords(waypoints_upd); // prepare lon/lat array
					let coordsTransformed_upd = projectFunction(coords_upd);

					// Concatenate with already existing data
					waypoints = waypoints.concat(waypoints_upd);
					coords = coords.concat(coords_upd);

					// Update track
					trackLine.setCoordinates(coords);
					trackLine.applyTransform(projectFunction);

					// Update marker
					markerPoint.setCoordinates(ol.proj.fromLonLat(coords[coords.length-1]));

					// Center map on track
					if (!waypoints || centerTrack) centerMapOnTrack();

					// ======= Update info on page =======
					let lwp = waypoints[waypoints.length - 1]; // last waypoint

					// Update track_started_at info
					if (lwp.timestamp_log) time_on_start_obj.innerText = waypoints[0].timestamp_log;
					else if (lwp.timestamp_server) time_on_start_obj.innerText = waypoints[0].timestamp_server + ' (request time)';
					else time_on_start_obj.innerText = "unknown";
					// Update last_update
					if (lwp.timestamp_log) time_at_marker_obj.innerText = lwp.timestamp_log;
					else if (lwp.timestamp_server) time_at_marker_obj.innerText = lwp.timestamp_server + ' (request time)';
					else time_at_marker_obj.innerText = "unknown";
					// Update current_speed
					if (lwp.speed)  speed_at_marker_obj.innerText = Number(parseFloat(lwp.speed) * 3.6).toFixed(1) + " km/h";
					else speed_at_marker_obj.innerText = "unknown";
					// Update travelled distance
					dst_travelled_obj.innerText = formatLength(trackLine);
				}

				// Update last_update info
				last_refresh_obj.innerText = getFormattedDate();
			});
		}; updateWaypoints(true); // initial update with full track

		// onClick for [update] button
		document.getElementById('update_btn').addEventListener('click', function(e) {
			updateWaypoints();
			setUpdateInterval();
		});

		// Popup on cursor
		var popupContent = document.getElementById('popup-content');
		var popupCloser = document.getElementById('popup-closer');

		var cursorOverlay = new ol.Overlay({
			element: document.getElementById('popup'),
			autoPan: true,
			autoPanAnimation: {
				duration: 10
			}
		});
		function closePopup() {
			cursorOverlay.setPosition(undefined);
			popupCloser.blur();
			arbitraryPopup = false;
		}
		popupCloser.onclick = function() {
			closePopup();
			return false;
		};

		var layerTrack = new ol.layer.Vector({
			name: 'Track',
			source: sourceTrack,
			style: styleTrack
		});
		var map = new ol.Map({
			target: 'map',
			layers: [
				new ol.layer.Tile({
					name: 'Tile',
					source: new ol.source.OSM()
				}),
				layerTrack,
				new ol.layer.Vector({
					name: 'Marker',
					source: sourceMarker,
					style: styleMarker
				})
			],
			view: new ol.View({
				center: ol.proj.fromLonLat([37.41, 8.82]),
				zoom: 4
			}),
			controls: ol.control.defaults().extend([
					new CustomControl({
						label: '⯐',
						className: 'ol-control-marker ol-control-custom',
						callback: centerMapOnMarker
					}),
					new CustomControl({
						label: '⌂',
						className: 'ol-control-home ol-control-custom',
						callback: centerMapOnTrack
					})
			]),
			overlays: [cursorOverlay]
		});
		map.addControl(new ol.control.ScaleLine({bar: true, text: false}));
		map.addControl(new ol.control.FullScreen());
		map.addControl(new ol.control.Control({ element: document.getElementById('cur_info_container') }));

		var refresh_interval_obj = document.getElementById('refresh_interval');
		var time_at_marker_obj = document.getElementById('time_at_marker');
		var time_on_start_obj = document.getElementById('time_on_start');
		var speed_at_marker_obj = document.getElementById('speed_at_marker');
		var dst_travelled_obj = document.getElementById('dst_travelled');
		var last_refresh_obj = document.getElementById('last_refresh');

		var cur_info_container_obj = document.getElementById('cur_info_container');
		var cur_sender_obj = document.getElementById('cur_sender');
		var cur_timestamp_obj = document.getElementById('cur_timestamp');
		var cur_speed_obj = document.getElementById('cur_speed');
		var cur_ele_obj = document.getElementById('cur_ele');

		// Autorefresh part
		var refresh_interval = parseInt(refresh_interval_obj.options[refresh_interval_obj.selectedIndex].value);
		var refresh_interval_id = null;
		refresh_interval_obj.onchange = function() {
			// console.log('onchange');
			refresh_interval = parseInt(refresh_interval_obj.options[refresh_interval_obj.selectedIndex].value);
			setUpdateInterval();
		};
		var setUpdateInterval = function() {
			// console.log('setUpdateInterval: ' + refresh_interval);
			if (refresh_interval_id)  clearInterval(refresh_interval_id);
			if (refresh_interval > 0) {
				refresh_interval_id = window.setInterval(updateWaypoints, refresh_interval);
			}
		}; setUpdateInterval();

		// Cursor part
		var cursor = null;
		var arbitraryPopup = false; // true, if popup shows non-track point atm. needed to trigger closePopup() correctly
		// Pointer onMouseMove
		var displayCursor = function(coord, click=false, alt=false) {
			let closestPoint = trackLine.getClosestPoint(coord);
			if (Math.sqrt(Math.pow(closestPoint[0] - coord[0], 2) + Math.pow(closestPoint[1] - coord[1], 2)) > CURSOR_TOLERANCE) {
				// Cursor not in tolerance
				cursor = null;
				map.render();
				// Hide info panel
				cur_info_container_obj.style.display = "none";
				// If not in tolerance and no alt (i.e. track point request) ~ ordinary click on map -> close popup
				if (click && !alt) {
					closePopup();
				}
			} else {
				// Cursor in tolerance
				if (cursor === null)  cursor = new ol.geom.Point(closestPoint);
				else cursor.setCoordinates(closestPoint);
				map.render();

				// Trying to find closest segment of trackLine
				let closestSegment = findClosestSegment(trackLine.getCoordinates(), closestPoint);
				let ind = closestSegment[0];
				let t = closestSegment[1];

				let wp = null;
				if (ind && t)  wp = waypoints[ind];

				let infoContent = '';
				if (wp) { // Updating info on page if found
					let timestamp = (wp.timestamp_log ? wp.timestamp_log : wp.timestamp_server);
					let speed = null;
					let ele = null;
					let sender = null;
					if (wp.speed) speed = Number(parseFloat(wp.speed) * 3.6).toFixed(1) + " km/h";
					if (wp.altitude) ele = Number(parseFloat(wp.altitude)).toFixed(1) + " m";
					if (wp.sender) sender = wp.sender;

					// Info panel in the bottom-right corner
					cur_info_container_obj.style.display = "block";
					cur_sender_obj.innerText = sender ? sender : 'unknown';
					cur_timestamp_obj.innerText = timestamp;
					cur_speed_obj.innerText = speed ? speed : 'unknown';
					cur_ele_obj.innerText = ele ? ele : 'unknown';

					// Info for popup
					infoContent = '';
					if (sender) infoContent += sender;
					infoContent += (infoContent.length > 0 ? '<br>' : '') + timestamp;
					if (speed) infoContent += '<br>' + speed;
					if (ele) infoContent += '<br>' + ele;
				}

				if (click && !alt) {
					// Click without alt but in tolerance lead to track-popup
					let hdms = ol.coordinate.toStringHDMS(ol.proj.toLonLat(closestPoint)).replace(/\s/g, '').replace(/N/g, 'N ');
					popupContent.innerHTML = '<code>' + hdms + '</code>';
					popupContent.innerHTML += '<p>' + infoContent + '</p>';
					arbitraryPopup = false;
					cursorOverlay.setPosition(closestPoint);
				}
			}
			if (click && alt) {
				// Independently of tolerance, if alt used with click, showing coordinate of exact click position
				let hdms = ol.coordinate.toStringHDMS(ol.proj.toLonLat(coord)).replace(/\s/g, '').replace(/N/g, 'N ');
				popupContent.innerHTML = '<code>' + hdms + '</code>';
				arbitraryPopup = true;
				cursorOverlay.setPosition(coord);
			}
		};
		map.on('pointermove', function(evt) {
			if (evt.dragging) return;
			var coord = map.getEventCoordinate(evt.originalEvent);
			displayCursor(coord);
		});
		map.on('click', function(evt) {
			displayCursor(evt.coordinate);
		});
		map.on('singleclick', function(evt) {
			displayCursor(evt.coordinate, true, evt.originalEvent.altKey);
		});

		layerTrack.on('postrender', function(evt) {
			var vectorContext = ol.render.getVectorContext(evt);
			vectorContext.setStyle(styleCursor);
			if (cursor !== null)
				vectorContext.drawGeometry(cursor);
		});
	</script>
</body>
</html>